<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="About" xml:space="preserve">
    <value>About Cepheus</value>
  </data>
  <data name="AddedToMinSpTree" xml:space="preserve">
    <value> added to minimum spanning tree.</value>
  </data>
  <data name="AddedWithReserve" xml:space="preserve">
    <value> added with reserve </value>
  </data>
  <data name="AndSurplus" xml:space="preserve">
    <value> and surplus: </value>
  </data>
  <data name="AttemptToRun" xml:space="preserve">
    <value> attempts to run...</value>
  </data>
  <data name="BFAlgo" xml:space="preserve">
    <value>Bellman-Ford's algorithm</value>
  </data>
  <data name="BFDesc" xml:space="preserve">
    <value>The Bellman–Ford algorithm is an algorithm that computes shortest paths from a single source vertex to all of the other vertices in a weighted digraph. It is slower than Dijkstra's algorithm for the same problem, but more versatile, as it is capable of handling graphs in which some of the edge weights are negative numbers.</value>
  </data>
  <data name="BFSAlgo" xml:space="preserve">
    <value>Breadth-first search</value>
  </data>
  <data name="BFSDesc" xml:space="preserve">
    <value>Breadth-first search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or some arbitrary node of a graph, sometimes referred to as a 'search key'), and explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.</value>
  </data>
  <data name="BFSTime" xml:space="preserve">
    <value>O(n + m)</value>
  </data>
  <data name="BFTime" xml:space="preserve">
    <value>O(n * m)</value>
  </data>
  <data name="BoruvkaAlgo" xml:space="preserve">
    <value>Boruvka's algorithm</value>
  </data>
  <data name="BoruvkaDesc" xml:space="preserve">
    <value>Description is not implemented.</value>
  </data>
  <data name="BoruvkaTime" xml:space="preserve">
    <value>m * log(n)</value>
  </data>
  <data name="BracketsHeight" xml:space="preserve">
    <value>In brackets after name of a vertex you see its height.</value>
  </data>
  <data name="CantWrite" xml:space="preserve">
    <value>Can't write to the selected file. Please check if the file is closed.</value>
  </data>
  <data name="ChooseAlgo" xml:space="preserve">
    <value>You have to choose an algorithm in the upper left corner corner.</value>
  </data>
  <data name="CleaningReserveNet" xml:space="preserve">
    <value>Cleaning the network of reserves...</value>
  </data>
  <data name="ClearCanvas.Content" xml:space="preserve">
    <value>Clear canvas</value>
  </data>
  <data name="Closed" xml:space="preserve">
    <value>Closed</value>
  </data>
  <data name="CloseTime" xml:space="preserve">
    <value> has been closed in time: </value>
  </data>
  <data name="CommonGraphs" xml:space="preserve">
    <value>Common graphs</value>
  </data>
  <data name="ConstructingPath" xml:space="preserve">
    <value>Constructing the path from source to sink...</value>
  </data>
  <data name="ContextComponentInicialized" xml:space="preserve">
    <value>Context components are inicialized.</value>
  </data>
  <data name="ContextComponentsMerging" xml:space="preserve">
    <value>Context components are merging...</value>
  </data>
  <data name="Continue" xml:space="preserve">
    <value>Please, press Done button to continue. The flow from edges will be removed.</value>
  </data>
  <data name="CreatingReserveNet" xml:space="preserve">
    <value>Creating the network of reserves...</value>
  </data>
  <data name="Cursor" xml:space="preserve">
    <value>Cursor</value>
  </data>
  <data name="Czech" xml:space="preserve">
    <value>Czech</value>
  </data>
  <data name="DefaultColor" xml:space="preserve">
    <value>Default color</value>
  </data>
  <data name="Dequed" xml:space="preserve">
    <value> has been dequeued.</value>
  </data>
  <data name="Desc" xml:space="preserve">
    <value>Description of algorithm</value>
  </data>
  <data name="DFSAlgo" xml:space="preserve">
    <value>Depth-first search</value>
  </data>
  <data name="DFSDesc" xml:space="preserve">
    <value>Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking.</value>
  </data>
  <data name="DFSTime" xml:space="preserve">
    <value>O(n + m)</value>
  </data>
  <data name="DijkstraAlgo" xml:space="preserve">
    <value>Dijkstra's algorithm with binary heap</value>
  </data>
  <data name="DijkstraDesc" xml:space="preserve">
    <value>Dijkstra's algorithm (or Dijkstra's Shortest Path First algorithm, SPF algorithm) is an algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks.</value>
  </data>
  <data name="DijkstraPosLengths" xml:space="preserve">
    <value>In Dijkstra's algorithm can be only positive lengths. Please, correct all negative lengths and then press Run again.</value>
  </data>
  <data name="DijkstraTime" xml:space="preserve">
    <value>O((n + m) * log(n))</value>
  </data>
  <data name="DinicAlgo" xml:space="preserve">
    <value>Dinic's algorithm</value>
  </data>
  <data name="DinicDescription" xml:space="preserve">
    <value>Dinic's algorithm or Dinitz's algorithm is a strongly polynomial algorithm for computing the maximum flow in a flow network, conceived in 1970 by Israeli (formerly Soviet) computer scientist Yefim (Chaim) A. Dinitz. The algorithm runs in O(n^2 * m) time and is similar to the Edmonds–Karp algorithm, which runs in O(n * m^2) time, in that it uses shortest augmenting paths. The introduction of the concepts of the level graph and blocking flow enable Dinic's algorithm to achieve its performance.</value>
  </data>
  <data name="DinicTime" xml:space="preserve">
    <value>O(n^2 * m)</value>
  </data>
  <data name="DividingVertices" xml:space="preserve">
    <value>Dividing vertices to layers according to their distance from the source...</value>
  </data>
  <data name="Done" xml:space="preserve">
    <value>Done</value>
  </data>
  <data name="EdgesInicialized" xml:space="preserve">
    <value>Edges are initialized...</value>
  </data>
  <data name="English" xml:space="preserve">
    <value>English</value>
  </data>
  <data name="Enqued" xml:space="preserve">
    <value> has been enqueued.</value>
  </data>
  <data name="Error" xml:space="preserve">
    <value>Error</value>
  </data>
  <data name="FFAlgo" xml:space="preserve">
    <value>Ford-Fulkerson's algorithm</value>
  </data>
  <data name="FFDesc" xml:space="preserve">
    <value>The Ford–Fulkerson method or Ford–Fulkerson algorithm (FFA) is a greedy algorithm that computes the maximum flow in a flow network. It is sometimes called a \"method\" instead of an \"algorithm\" as the approach to finding augmenting paths in a residual graph is not fully specified or it is specified in several implementations with different running times. It was published in 1956 by L. R. Ford Jr. and D. R. Fulkerson. The name \"Ford–Fulkerson\" is often also used for the Edmonds–Karp algorithm, which is a fully defined implementation of the Ford–Fulkerson method. "</value>
  </data>
  <data name="FFTime" xml:space="preserve">
    <value>O(m * f)</value>
  </data>
  <data name="FileEmpty" xml:space="preserve">
    <value>The file is empty.</value>
  </data>
  <data name="FillColor" xml:space="preserve">
    <value>Fill color</value>
  </data>
  <data name="FromInitVPred" xml:space="preserve">
    <value> from initial vertex with predecessor </value>
  </data>
  <data name="FWAlgo" xml:space="preserve">
    <value>Floyd-Warshall's algorithm</value>
  </data>
  <data name="FWDesc" xml:space="preserve">
    <value>In computer science, the Floyd–Warshall algorithm (also known as Floyd's algorithm, the Roy–Warshall algorithm, the Roy–Floyd algorithm, or the WFI algorithm) is an algorithm for finding shortest paths in a weighted graph with positive or negative edge weights (but with no negative cycles). A single execution of the algorithm will find the lengths (summed weights) of shortest paths between all pairs of vertices. Although it does not return details of the paths themselves, it is possible to reconstruct the paths with simple modifications to the algorithm.</value>
  </data>
  <data name="FWTime" xml:space="preserve">
    <value>O(n^3)</value>
  </data>
  <data name="GoldbergAlgo" xml:space="preserve">
    <value>Goldberg's algorithm</value>
  </data>
  <data name="GoldbergDesc" xml:space="preserve">
    <value>In mathematical optimization, the push–relabel algorithm (alternatively, preflow–push algorithm) is an algorithm for computing maximum flows in a flow network. The name \push–relabel\" comes from the two basic operations used in the algorithm. Throughout its execution, the algorithm maintains a \"preflow\" and gradually converts it into a maximum flow by moving flow locally between neighboring nodes using push operations under the guidance of an admissible network maintained by relabel operations. In comparison, the Ford–Fulkerson algorithm performs global augmentations that send flow following paths from the source all the way to the sink.</value>
  </data>
  <data name="GoldbergTime" xml:space="preserve">
    <value>O(n^2 * m)</value>
  </data>
  <data name="HasFinished" xml:space="preserve">
    <value> has finished.</value>
  </data>
  <data name="HasHeight" xml:space="preserve">
    <value> has height: </value>
  </data>
  <data name="HasId" xml:space="preserve">
    <value> has ID: </value>
  </data>
  <data name="HasState" xml:space="preserve">
    <value> has state: </value>
  </data>
  <data name="HighlightColor" xml:space="preserve">
    <value>Highlight color</value>
  </data>
  <data name="Import" xml:space="preserve">
    <value>Open graph</value>
  </data>
  <data name="ImproveFlow" xml:space="preserve">
    <value>Improving the flow...</value>
  </data>
  <data name="IncorrectFormat" xml:space="preserve">
    <value>File has an incorrect format.</value>
  </data>
  <data name="Infinity" xml:space="preserve">
    <value>Infinity</value>
  </data>
  <data name="Inside" xml:space="preserve">
    <value>Inside</value>
  </data>
  <data name="IsInComp" xml:space="preserve">
    <value> is in component: </value>
  </data>
  <data name="IsInDistance" xml:space="preserve">
    <value> and is in distance: </value>
  </data>
  <data name="JarnikAlgo" xml:space="preserve">
    <value>Jarnik's algorithm</value>
  </data>
  <data name="JarnikDesc" xml:space="preserve">
    <value>In computer science, Prim's (also known as Jarník's) algorithm is a greedy algorithm that finds a minimum spanning tree for a weighted undirected graph. This means it finds a subset of the edges that forms a tree that includes every vertex, where the total weight of all the edges in the tree is minimized. The algorithm operates by building this tree one vertex at a time, from an arbitrary starting vertex, at each step adding the cheapest possible connection from the tree to another vertex.</value>
  </data>
  <data name="JarnikTime" xml:space="preserve">
    <value>O(m * log(n))</value>
  </data>
  <data name="KruskalAlgo" xml:space="preserve">
    <value>Kruskal's algorithm</value>
  </data>
  <data name="KruskalDesc" xml:space="preserve">
    <value>Kruskal's algorithm is a minimum-spanning-tree algorithm which finds an edge of the least possible weight that connects any two trees in the forest. It is a greedy algorithm in graph theory as it finds a minimum spanning tree for a connected weighted graph adding increasing cost arcs at each step. This means it finds a subset of the edges that forms a tree that includes every vertex, where the total weight of all the edges in the tree is minimized. If the graph is not connected, then it finds a minimum spanning forest (a minimum spanning tree for each connected component).</value>
  </data>
  <data name="KruskalTime" xml:space="preserve">
    <value>O(m * log(n))</value>
  </data>
  <data name="LowestReserve" xml:space="preserve">
    <value>The lowest reserve is </value>
  </data>
  <data name="MarkingSurplus" xml:space="preserve">
    <value>Marking vertices with positive surplus...</value>
  </data>
  <data name="MatrixDist" xml:space="preserve">
    <value>Matrix of distances: </value>
  </data>
  <data name="MaxFlow" xml:space="preserve">
    <value>The maximum flow in this network is: </value>
  </data>
  <data name="Mistake" xml:space="preserve">
    <value>Some mistake occured...</value>
  </data>
  <data name="Neighbour" xml:space="preserve">
    <value>Neighbour</value>
  </data>
  <data name="Net of reserves" xml:space="preserve">
    <value>Net of reserves</value>
  </data>
  <data name="NLEdgeSpace" xml:space="preserve">
    <value>Edge </value>
  </data>
  <data name="NLTransfering" xml:space="preserve">
    <value>Transfering </value>
  </data>
  <data name="NLVertexSpace" xml:space="preserve">
    <value>Vertex </value>
  </data>
  <data name="NonAlgoSelected" xml:space="preserve">
    <value>No algorithm is selected.</value>
  </data>
  <data name="None" xml:space="preserve">
    <value>None</value>
  </data>
  <data name="NothingTransfered" xml:space="preserve">
    <value>Nothing was transfered.</value>
  </data>
  <data name="OfTheEdge" xml:space="preserve">
    <value> of the edge </value>
  </data>
  <data name="OnEdge" xml:space="preserve">
    <value> on edge </value>
  </data>
  <data name="OnlyInteger" xml:space="preserve">
    <value>Only integer length of an edge is acceptable...</value>
  </data>
  <data name="Open" xml:space="preserve">
    <value>Open</value>
  </data>
  <data name="OpenTime" xml:space="preserve">
    <value> has been opened in time: </value>
  </data>
  <data name="OpenVerticesSorted" xml:space="preserve">
    <value>Open vertices in sorted order (distance is in brackets): </value>
  </data>
  <data name="OutEdgesSorted" xml:space="preserve">
    <value>Outcoming edges are sorted from lightest to heaviest for each vertex.</value>
  </data>
  <data name="Outside" xml:space="preserve">
    <value>Outside</value>
  </data>
  <data name="PathDoesntExist" xml:space="preserve">
    <value>Path from source to sink in the net of reserves doesn't exist.</value>
  </data>
  <data name="Print" xml:space="preserve">
    <value>Print graph</value>
  </data>
  <data name="ProblemReading" xml:space="preserve">
    <value>There is some problem with reading this file. Please, try it again.</value>
  </data>
  <data name="RelaxAlgo" xml:space="preserve">
    <value>Relaxation algorithm</value>
  </data>
  <data name="RelaxDesc" xml:space="preserve">
    <value>Description is not implemented.</value>
  </data>
  <data name="RelaxTime" xml:space="preserve">
    <value>O(n^2)</value>
  </data>
  <data name="RemovedFromReserveNet" xml:space="preserve">
    <value> is removed from the network of reserves.</value>
  </data>
  <data name="RemovingBackEdges" xml:space="preserve">
    <value>Removing every edge to previous layers or edges inside layers...</value>
  </data>
  <data name="RemovingFarVertices" xml:space="preserve">
    <value>Removing every vertex which is further from source than sink...</value>
  </data>
  <data name="RemovingNoOutVertices" xml:space="preserve">
    <value>Removing vertices with no outcoming edges...</value>
  </data>
  <data name="RemovingSaturatedEdges" xml:space="preserve">
    <value>Removing saturated edges...</value>
  </data>
  <data name="Run" xml:space="preserve">
    <value>Run</value>
  </data>
  <data name="Save" xml:space="preserve">
    <value>Save graph</value>
  </data>
  <data name="SearchingPath" xml:space="preserve">
    <value>Looking for a path from source to sink using BFS algorithm...</value>
  </data>
  <data name="SelectedAlgoRunning" xml:space="preserve">
    <value>Selected algorithm is running.</value>
  </data>
  <data name="SelectInit" xml:space="preserve">
    <value>Select the initial vertex. Then press green Done button.</value>
  </data>
  <data name="SelectSink" xml:space="preserve">
    <value>Select the sink vertex and press Done again.</value>
  </data>
  <data name="SelectSource" xml:space="preserve">
    <value>Select the source vertex. Then press green Done button.</value>
  </data>
  <data name="ShortesPathContain" xml:space="preserve">
    <value>The shortest path can contain vertices with index from 0 to </value>
  </data>
  <data name="ShortestPathContains" xml:space="preserve">
    <value>The shortest path from source to sink conatins </value>
  </data>
  <data name="SinkNotReachable" xml:space="preserve">
    <value>The sink is not reachable from the source.</value>
  </data>
  <data name="SortedNeighbours" xml:space="preserve">
    <value>Sorted neighbours are (rating is in parenthesses):</value>
  </data>
  <data name="SpaceEdges" xml:space="preserve">
    <value> edges.</value>
  </data>
  <data name="TimeComplexity" xml:space="preserve">
    <value>Time complexity: </value>
  </data>
  <data name="TransferingSurplus" xml:space="preserve">
    <value>Transfering surplus...</value>
  </data>
  <data name="TroubleDel" xml:space="preserve">
    <value>If you have troubles with deleting vertices or edges, try to press Tab so names and lengths will lose focus.</value>
  </data>
  <data name="Tutorial" xml:space="preserve">
    <value>Tutorial</value>
  </data>
  <data name="Unvisited" xml:space="preserve">
    <value>Unvisited</value>
  </data>
  <data name="VertexHash" xml:space="preserve">
    <value>Vertex #</value>
  </data>
  <data name="VerticesInicialized" xml:space="preserve">
    <value>Vertices are initialized...</value>
  </data>
  <data name="VerticisSurplus" xml:space="preserve">
    <value>Vertices with positive surplus are staying marked.</value>
  </data>
  <data name="Welcome" xml:space="preserve">
    <value>Welcome to Cepheus. Feel free to create any graphs you want and experiment with the prepared algorithms. If you're using this app for the first time, there's a tutorial made right for you in the upper right corner.</value>
  </data>
  <data name="WithPred" xml:space="preserve">
    <value> with predecessor </value>
  </data>
  <data name="WithRating" xml:space="preserve">
    <value> with rating: </value>
  </data>
  <data name="ZoomIn" xml:space="preserve">
    <value>Zoom in</value>
  </data>
  <data name="ZoomOut" xml:space="preserve">
    <value>Zoom out</value>
  </data>
</root>