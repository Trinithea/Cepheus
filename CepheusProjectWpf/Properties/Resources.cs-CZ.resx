<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="About" xml:space="preserve">
    <value>O aplikaci Cepheus</value>
  </data>
  <data name="AboutLong" xml:space="preserve">
    <value>Aplikace Cepheus slouží jako doplňková aplikace ke studiu různých grafových algoritmů. Student (nebo jakýkoli jiný uživatel) může v aplikaci sestrojit zcela vlastní graf, a na něm spustit jeden z nabídky dvanácti algoritmů probíraných v ADS I či ADS II. Chod algoritmu může sledovat jak animací na vlastním grafu (tedy které vrcholy a hrany zrovna algoritmus prochází – lze poznat ze zbarvení), tak v postupném výpisu jednotlivých kroků.</value>
  </data>
  <data name="AddedToMinSpTree" xml:space="preserve">
    <value> je přidaná do minimální kostry.</value>
  </data>
  <data name="AddedWithReserve" xml:space="preserve">
    <value> je přidaná s rezervou </value>
  </data>
  <data name="AndSurplus" xml:space="preserve">
    <value> a přebytek: </value>
  </data>
  <data name="AttemptToRun" xml:space="preserve">
    <value> se snaží spustit...</value>
  </data>
  <data name="BFAlgo" xml:space="preserve">
    <value>Bellman-Fordův algoritmus</value>
  </data>
  <data name="BFDesc" xml:space="preserve">
    <value>The Bellman–Ford algorithm is an algorithm that computes shortest paths from a single source vertex to all of the other vertices in a weighted digraph. It is slower than Dijkstra's algorithm for the same problem, but more versatile, as it is capable of handling graphs in which some of the edge weights are negative numbers.</value>
  </data>
  <data name="BFSAlgo" xml:space="preserve">
    <value>Prohledávání do šířky</value>
  </data>
  <data name="BFSDesc" xml:space="preserve">
    <value>Breadth-first search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or some arbitrary node of a graph, sometimes referred to as a 'search key'), and explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.</value>
  </data>
  <data name="BFSTime" xml:space="preserve">
    <value>O(n + m)</value>
  </data>
  <data name="BFTime" xml:space="preserve">
    <value>O(n * m)</value>
  </data>
  <data name="BoruvkaAlgo" xml:space="preserve">
    <value>Borůvkův algoritmus</value>
  </data>
  <data name="BoruvkaDesc" xml:space="preserve">
    <value>Description is not implemented.</value>
  </data>
  <data name="BoruvkaTime" xml:space="preserve">
    <value>m * log(n)</value>
  </data>
  <data name="BracketsHeight" xml:space="preserve">
    <value>V závorkách za jménem vrcholu uvidíte jeho výšku.</value>
  </data>
  <data name="CantContainSemicolon" xml:space="preserve">
    <value>Jméno vrcholu nemůže obsahovat středník.</value>
  </data>
  <data name="CantWrite" xml:space="preserve">
    <value>Zápis do souboru nemůže být proveden. Zkontrolujte, že je soubor zavřený.</value>
  </data>
  <data name="ChooseAlgo" xml:space="preserve">
    <value>Musíte nejprve vlevo nahoře zvolit z nabídky algoritmus, který chcete spustit.</value>
  </data>
  <data name="CleaningReserveNet" xml:space="preserve">
    <value>Čištění sítě rezerv…</value>
  </data>
  <data name="ClearCanvas.Content" xml:space="preserve">
    <value>Vyčisti plátno</value>
  </data>
  <data name="Closed" xml:space="preserve">
    <value>Uzavřený</value>
  </data>
  <data name="CloseTime" xml:space="preserve">
    <value> byl uzavřen v čase: </value>
  </data>
  <data name="CommonGraphs" xml:space="preserve">
    <value>Grafy z Průvodce labyrintem algoritmů</value>
  </data>
  <data name="ComponentId" xml:space="preserve">
    <value>V závorkách je ID komponenty, ve které se vrchol nachází.</value>
  </data>
  <data name="ConstructingPath" xml:space="preserve">
    <value>Konstrukce cesty ze zdroje ke stoku…</value>
  </data>
  <data name="ContextComponentInicialized" xml:space="preserve">
    <value>Komponenty souvislosti jsou inicializovány.</value>
  </data>
  <data name="ContextComponentsMerging" xml:space="preserve">
    <value>Slévání komponent souvislosti…</value>
  </data>
  <data name="Continue" xml:space="preserve">
    <value>Abyste mohli pokračovat, stiskněte prosím Hotovo. Pak se smaže tok z hran.</value>
  </data>
  <data name="CreatingReserveNet" xml:space="preserve">
    <value>Vytváření sítě rezerv…</value>
  </data>
  <data name="Cursor" xml:space="preserve">
    <value>Kurzor</value>
  </data>
  <data name="Czech" xml:space="preserve">
    <value>Čeština</value>
  </data>
  <data name="DefaultColor" xml:space="preserve">
    <value>Základní barva</value>
  </data>
  <data name="Dequed" xml:space="preserve">
    <value> byl odebrán z fronty.</value>
  </data>
  <data name="Desc" xml:space="preserve">
    <value>Popis algoritmu</value>
  </data>
  <data name="DFSAlgo" xml:space="preserve">
    <value>Prohledávání do hloubky</value>
  </data>
  <data name="DFSDesc" xml:space="preserve">
    <value>Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking.</value>
  </data>
  <data name="DFSTime" xml:space="preserve">
    <value>O(n + m)</value>
  </data>
  <data name="DijkstraAlgo" xml:space="preserve">
    <value>Dijsktrův algoritmus s binární haldou</value>
  </data>
  <data name="DijkstraDesc" xml:space="preserve">
    <value>Dijkstra's algorithm (or Dijkstra's Shortest Path First algorithm, SPF algorithm) is an algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks.</value>
  </data>
  <data name="DijkstraPosLengths" xml:space="preserve">
    <value> může obsahovat pouze nezáporné délky hran. Opravte tedy všechny záporné délky a znovu stiskněte Spustit.</value>
  </data>
  <data name="DijkstraTime" xml:space="preserve">
    <value>O((n + m) * log(n))</value>
  </data>
  <data name="DinicAlgo" xml:space="preserve">
    <value>Dinicův algoritmus</value>
  </data>
  <data name="DinicDescription" xml:space="preserve">
    <value>Dinic's algorithm or Dinitz's algorithm is a strongly polynomial algorithm for computing the maximum flow in a flow network, conceived in 1970 by Israeli (formerly Soviet) computer scientist Yefim (Chaim) A. Dinitz. The algorithm runs in O(n^2 * m) time and is similar to the Edmonds–Karp algorithm, which runs in O(n * m^2) time, in that it uses shortest augmenting paths. The introduction of the concepts of the level graph and blocking flow enable Dinic's algorithm to achieve its performance.</value>
  </data>
  <data name="DinicTime" xml:space="preserve">
    <value>O(n^2 * m)</value>
  </data>
  <data name="DividingVertices" xml:space="preserve">
    <value>Rozdělení vcholů na vrstvy dle vzdálenosti od zdroje…</value>
  </data>
  <data name="Done" xml:space="preserve">
    <value>Hotovo</value>
  </data>
  <data name="EdgesInicialized" xml:space="preserve">
    <value>Inicializace hran…</value>
  </data>
  <data name="English" xml:space="preserve">
    <value>Angličtina</value>
  </data>
  <data name="Enqued" xml:space="preserve">
    <value> byl přidán do fronty.</value>
  </data>
  <data name="Error" xml:space="preserve">
    <value>Chyba</value>
  </data>
  <data name="FFAlgo" xml:space="preserve">
    <value>Ford-Fulkersonův algoritmus</value>
  </data>
  <data name="FFDesc" xml:space="preserve">
    <value>The Ford–Fulkerson method or Ford–Fulkerson algorithm (FFA) is a greedy algorithm that computes the maximum flow in a flow network. It is sometimes called a \"method\" instead of an \"algorithm\" as the approach to finding augmenting paths in a residual graph is not fully specified or it is specified in several implementations with different running times. It was published in 1956 by L. R. Ford Jr. and D. R. Fulkerson. The name \"Ford–Fulkerson\" is often also used for the Edmonds–Karp algorithm, which is a fully defined implementation of the Ford–Fulkerson method. "</value>
  </data>
  <data name="FFTime" xml:space="preserve">
    <value>O(m * f)</value>
  </data>
  <data name="FileEmpty" xml:space="preserve">
    <value>Soubor je prázdný.</value>
  </data>
  <data name="FillColor" xml:space="preserve">
    <value>Vyplnit barvou</value>
  </data>
  <data name="FromInitVPred" xml:space="preserve">
    <value> od počátečního vrcholu s předchůdcem </value>
  </data>
  <data name="FWAlgo" xml:space="preserve">
    <value>Floyd-Warshallův algoritmus</value>
  </data>
  <data name="FWDesc" xml:space="preserve">
    <value>In computer science, the Floyd–Warshall algorithm (also known as Floyd's algorithm, the Roy–Warshall algorithm, the Roy–Floyd algorithm, or the WFI algorithm) is an algorithm for finding shortest paths in a weighted graph with positive or negative edge weights (but with no negative cycles). A single execution of the algorithm will find the lengths (summed weights) of shortest paths between all pairs of vertices. Although it does not return details of the paths themselves, it is possible to reconstruct the paths with simple modifications to the algorithm.</value>
  </data>
  <data name="FWTime" xml:space="preserve">
    <value>O(n^3)</value>
  </data>
  <data name="GoldbergAlgo" xml:space="preserve">
    <value>Goldbergův algoritmus</value>
  </data>
  <data name="GoldbergDesc" xml:space="preserve">
    <value>In mathematical optimization, the push–relabel algorithm (alternatively, preflow–push algorithm) is an algorithm for computing maximum flows in a flow network. The name \push–relabel\" comes from the two basic operations used in the algorithm. Throughout its execution, the algorithm maintains a \"preflow\" and gradually converts it into a maximum flow by moving flow locally between neighboring nodes using push operations under the guidance of an admissible network maintained by relabel operations. In comparison, the Ford–Fulkerson algorithm performs global augmentations that send flow following paths from the source all the way to the sink.</value>
  </data>
  <data name="GoldbergTime" xml:space="preserve">
    <value>O(n^2 * m)</value>
  </data>
  <data name="HasFinished" xml:space="preserve">
    <value> skončil.</value>
  </data>
  <data name="HasHeight" xml:space="preserve">
    <value> má výšku: </value>
  </data>
  <data name="HasId" xml:space="preserve">
    <value> má ID: </value>
  </data>
  <data name="HasState" xml:space="preserve">
    <value> je </value>
  </data>
  <data name="HighlightColor" xml:space="preserve">
    <value>Zvýrazňující barva</value>
  </data>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="imgTutorial" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\tutorialcs-CZ smaller.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="Import" xml:space="preserve">
    <value>Otevřít graf</value>
  </data>
  <data name="ImproveFlow" xml:space="preserve">
    <value>Zlepšování toku…</value>
  </data>
  <data name="IncorrectFormat" xml:space="preserve">
    <value>Soubor má špatný formát.</value>
  </data>
  <data name="Infinity" xml:space="preserve">
    <value>∞</value>
  </data>
  <data name="Inside" xml:space="preserve">
    <value>Uvnitř</value>
  </data>
  <data name="IsInComp" xml:space="preserve">
    <value> je v komponentě: </value>
  </data>
  <data name="IsInDistance" xml:space="preserve">
    <value> a je ve vzdálenosti: </value>
  </data>
  <data name="JarnikAlgo" xml:space="preserve">
    <value>Jarníkův algoritmus</value>
  </data>
  <data name="JarnikDesc" xml:space="preserve">
    <value>In computer science, Prim's (also known as Jarník's) algorithm is a greedy algorithm that finds a minimum spanning tree for a weighted undirected graph. This means it finds a subset of the edges that forms a tree that includes every vertex, where the total weight of all the edges in the tree is minimized. The algorithm operates by building this tree one vertex at a time, from an arbitrary starting vertex, at each step adding the cheapest possible connection from the tree to another vertex.</value>
  </data>
  <data name="JarnikTime" xml:space="preserve">
    <value>O(m * log(n))</value>
  </data>
  <data name="KruskalAlgo" xml:space="preserve">
    <value>Kruskalův algoritmus</value>
  </data>
  <data name="KruskalDesc" xml:space="preserve">
    <value>Kruskal's algorithm is a minimum-spanning-tree algorithm which finds an edge of the least possible weight that connects any two trees in the forest. It is a greedy algorithm in graph theory as it finds a minimum spanning tree for a connected weighted graph adding increasing cost arcs at each step. This means it finds a subset of the edges that forms a tree that includes every vertex, where the total weight of all the edges in the tree is minimized. If the graph is not connected, then it finds a minimum spanning forest (a minimum spanning tree for each connected component).</value>
  </data>
  <data name="KruskalTime" xml:space="preserve">
    <value>O(m * log(n))</value>
  </data>
  <data name="LowestReserve" xml:space="preserve">
    <value>Nejmenší z rezerv je </value>
  </data>
  <data name="MarkingSurplus" xml:space="preserve">
    <value>Označování vrcholů s kladným přebytkem…</value>
  </data>
  <data name="MatrixDist" xml:space="preserve">
    <value>Matice vzdáleností:</value>
  </data>
  <data name="MaxFlow" xml:space="preserve">
    <value>Maximální tok v této síti je: </value>
  </data>
  <data name="Mistake" xml:space="preserve">
    <value>Objevila se nějaká chyba...</value>
  </data>
  <data name="Neighbour" xml:space="preserve">
    <value>Soused</value>
  </data>
  <data name="Net of reserves" xml:space="preserve">
    <value>Síť rezerv</value>
  </data>
  <data name="NLEdgeSpace" xml:space="preserve">
    <value>Hrana </value>
  </data>
  <data name="NLTransfering" xml:space="preserve">
    <value>Převádění </value>
  </data>
  <data name="NLVertexSpace" xml:space="preserve">
    <value>Vrchol </value>
  </data>
  <data name="NonAlgoSelected" xml:space="preserve">
    <value>Není vybrán žádný algoritmus.</value>
  </data>
  <data name="None" xml:space="preserve">
    <value>Žádný</value>
  </data>
  <data name="NothingTransfered" xml:space="preserve">
    <value>Nic nebylo převedeno.</value>
  </data>
  <data name="OfTheEdge" xml:space="preserve">
    <value> hrany </value>
  </data>
  <data name="OnEdge" xml:space="preserve">
    <value> hranou </value>
  </data>
  <data name="OnlyInteger" xml:space="preserve">
    <value>Hrana může mít pouze celočíselnou délku…</value>
  </data>
  <data name="Open" xml:space="preserve">
    <value>Otevřený</value>
  </data>
  <data name="OpenTime" xml:space="preserve">
    <value> byl otevřen v čase: </value>
  </data>
  <data name="OpenVerticesSorted" xml:space="preserve">
    <value>Otevřené vrcholy v setříděném pořadí (jejich vzdálenost je v závorkách): </value>
  </data>
  <data name="OutEdgesSorted" xml:space="preserve">
    <value>Hrany vycházející z vrcholu jsou setříděny od nejlehčí po nejtěžší pro každý vrchol.</value>
  </data>
  <data name="Outside" xml:space="preserve">
    <value>Mimo</value>
  </data>
  <data name="PathDoesntExist" xml:space="preserve">
    <value>Cesta od zdroje ke stoku v síti rezerv neexistuje.</value>
  </data>
  <data name="Print" xml:space="preserve">
    <value>Vytisknout graf</value>
  </data>
  <data name="ProblemReading" xml:space="preserve">
    <value>Objevil se problém s načítáním tohoto souboru. Zkuste to prosím znovu.</value>
  </data>
  <data name="RelaxAlgo" xml:space="preserve">
    <value>Relaxační algoritmus</value>
  </data>
  <data name="RelaxDesc" xml:space="preserve">
    <value>Description is not implemented.</value>
  </data>
  <data name="RelaxTime" xml:space="preserve">
    <value>O(n^2)</value>
  </data>
  <data name="RemovedFromReserveNet" xml:space="preserve">
    <value> už není v síti rezerv.</value>
  </data>
  <data name="RemovingBackEdges" xml:space="preserve">
    <value>Odstranění všech hran vedoucích do předešlých vrstev nebo hran uvnitř vrstev…</value>
  </data>
  <data name="RemovingFarVertices" xml:space="preserve">
    <value>Odstranění všech vrcholů vzdálenějších od zdroje než stok…</value>
  </data>
  <data name="RemovingNoOutVertices" xml:space="preserve">
    <value>Odstranění všech slepých uliček…</value>
  </data>
  <data name="RemovingSaturatedEdges" xml:space="preserve">
    <value>Odstranění nasycencýh hran…</value>
  </data>
  <data name="Run" xml:space="preserve">
    <value>Spustit</value>
  </data>
  <data name="Save" xml:space="preserve">
    <value>Uložit graf</value>
  </data>
  <data name="SearchingPath" xml:space="preserve">
    <value>Hledání cesty ze zdroje do stoku prohledáváním do šířky…</value>
  </data>
  <data name="SelectedAlgoRunning" xml:space="preserve">
    <value>Vybraný algoritmus běží.</value>
  </data>
  <data name="SelectInit" xml:space="preserve">
    <value>Vyberte počáteční vrchol. Poté stiskněte zelené tlačítko Hotovo.</value>
  </data>
  <data name="SelectSink" xml:space="preserve">
    <value>Vyberte stok a pak stiskněte Hotovo.</value>
  </data>
  <data name="SelectSource" xml:space="preserve">
    <value>Vyberte zdroj. Poté stiskněte zelené tlačítko Hotovo.</value>
  </data>
  <data name="ShortesPathContain" xml:space="preserve">
    <value>The shortest path can contain vertices with index from 0 to </value>
  </data>
  <data name="ShortestPathContains" xml:space="preserve">
    <value>Nejkratší cesta od zdroje ke stoku obsahuje </value>
  </data>
  <data name="SinkNotReachable" xml:space="preserve">
    <value>Stok je ze zdroje nedostupný.</value>
  </data>
  <data name="SortedNeighbours" xml:space="preserve">
    <value>Setříděné sousední vrcholy jsou (jejich ohodnocení je v závorkách):</value>
  </data>
  <data name="SpaceEdges" xml:space="preserve">
    <value> hran(y).</value>
  </data>
  <data name="StateDistanceInfo" xml:space="preserve">
    <value>V závorkách je uveden stav vrcholu a jeho vzdálenost od počátečního vrcholu.</value>
  </data>
  <data name="StateInOutTime" xml:space="preserve">
    <value>V závorkách je stav vrcholu, čas příchodu a odchodu z vrcholu.</value>
  </data>
  <data name="StateRating" xml:space="preserve">
    <value>V závorkách je uveden stav vrcholu a jeho aktuální ohodnocení.</value>
  </data>
  <data name="TimeComplexity" xml:space="preserve">
    <value>Časová složitost: </value>
  </data>
  <data name="TransferingSurplus" xml:space="preserve">
    <value>Převádění přebytku…</value>
  </data>
  <data name="TroubleDel" xml:space="preserve">
    <value>If you have troubles with deleting vertices or edges, try to press Tab so names and lengths will lose focus.</value>
  </data>
  <data name="Tutorial" xml:space="preserve">
    <value>Tutoriál</value>
  </data>
  <data name="Unvisited" xml:space="preserve">
    <value>Nenalezený</value>
  </data>
  <data name="VertexHash" xml:space="preserve">
    <value>Vrchol #</value>
  </data>
  <data name="VerticesInicialized" xml:space="preserve">
    <value>Inicializace vrcholů…</value>
  </data>
  <data name="VerticisSurplus" xml:space="preserve">
    <value>Vrcholy s kladným přebytkem zůstávají označeny.</value>
  </data>
  <data name="Welcome" xml:space="preserve">
    <value>Vítejte v aplikaci Cepheus. Zde můžete vytvářet jakékoli grafy a zkoumat na nich, jak fungují nejrůznější algoritmy z naší nabídky. Pokud nevíte jak začít, tak v pravém hroním rohu najdete krátký tutoriál.</value>
  </data>
  <data name="WithPred" xml:space="preserve">
    <value> s předchůdcem </value>
  </data>
  <data name="WithRating" xml:space="preserve">
    <value> s ohodnocením: </value>
  </data>
  <data name="ZoomIn" xml:space="preserve">
    <value>Přiblížit</value>
  </data>
  <data name="ZoomOut" xml:space="preserve">
    <value>Oddálit</value>
  </data>
</root>